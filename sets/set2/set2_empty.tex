\newif\ifshowsolutions
\showsolutionstrue
\input{../preamble}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HEADER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chead{
  {\vbox{
      \vspace{2mm}
      \large
      Machine Learning \& Data Mining \hfill
      Caltech CS/CNS/EE 155 \hfill \\[1pt]
      Set 2\hfill
      January $19^\text{th}$, 2022 \\
    }
  }
}

\begin{document}
\pagestyle{fancy}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% POLICIES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \section*{Policies}
% \begin{itemize}
% 	\item Due 9 PM PST, January $19^\text{th}$ on Gradescope. 
% 	\item You are free to collaborate on all of the problems, subject to the collaboration policy stated in the syllabus.
% 	\item In this course, we will be using Google Colab for code submissions. You will need a Google account.
% \end{itemize}

% \section*{Submission Instructions}
% \begin{itemize}
% 	\item Submit your report as a single .pdf file to Gradescope (entry code 7426YK), under "Set 2 Report". 
% 	\item In the report, \textbf{include any images generated by your code} along with your answers to the questions.
% 	\item Submit your code by \textbf{sharing a link in your report} to your Google Colab notebook for each problem (see naming instructions below). Make sure to set sharing permissions to at least "Anyone with the link can view". \textbf{Links that can not be run by TAs will not be counted as turned in.} Check your links in an incognito window before submitting to be sure. 
% 	\item For instructions specifically pertaining to the Gradescope submission process, see \url{https://www.gradescope.com/get_started#student-submission}.
% \end{itemize}

% \section*{Google Colab Instructions}
% For each notebook, you need to save a copy to your drive.
% \begin{enumerate}
% 	\item Open the github preview of the notebook, and click the icon to open the colab preview.
% 	\item On the colab preview, go to File $\rightarrow$ Save a copy in Drive.
% 	\item Edit your file name to “lastname_firstname_set_problem”, e.g.”yue_yisong_set2_prob1.ipynb”
% \end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PROBLEM 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Comparing Different Loss Functions [30 Points]}
\materials{lecture 3 \& 4}

We've discussed three loss functions for linear classification models so far:
\begin{itemize}
\item Squared loss: $L_\text{squared} = (1 - y\mathbf{w}^T\mathbf{x})^2$
\item Hinge loss: $L_\text{hinge} = \max(0, 1 - y\mathbf{w}^T\mathbf{x})$
\item Log loss: $L_\text{log} = \ln(1 + e^{-y\mathbf{w}^T\mathbf{x}})$
\end{itemize}
where $\mathbf{w} \in \mathbb{R}^n$ is a vector of the model parameters, $y \in \{-1,1\}$ is the class label for datapoint $\mathbf{x} \in \mathbb{R}^n$, and we're including a bias term in $\mathbf{x}$ and $\mathbf{w}$.  The model classifies points according to $\text{sign}(\mathbf{w}^T\mathbf{x})$.

Performing gradient descent on any of these loss functions will train a model to classify more points correctly, but the choice of loss function has a significant impact on the model that is learned.

\problem[3]
Squared loss is often a terrible choice of loss function to train on for classification problems.  Why?

\begin{solution}
  Classifications problems compare the model output with discrete values corresponding to the different classes. When squared loss is computed on discrete classification values, it can penalize certain classes based on the numbering system. Squared loss is better for analyzing real valued functions, since there is a need to measure how inaccurate the model is. If the problem is classification, the model needs to classify correctly, which least-squares does a poor job of measuring how accurate the model is.
\end{solution}

\newpage

\problem[9]
A dataset is included with your problem set: \texttt{problem1data1.txt}. The first two columns represent $x_1, x_2$, and the last column represents the label, $y \in \{-1,+1\}$.

On this dataset, train both a logistic regression model and a ridge regression model to classify the points.  (In other words, on each dataset, train one linear classifier using $L_\text{log}$ as the loss, and another linear classifier using $L_\text{squared}$ as the loss.) For this problem, you should use the logistic regression and ridge regression implementations provided within scikit-learn 
(\href{http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html}{logistic regression documentation})
(\href{http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html}{Ridge regression documentation})
instead of your own implementations. Use the default parameters for these classifiers except for setting the regularization parameters so that very little regularization is applied.

For each loss function/model, plot the data points as a scatter plot and overlay them with the decision boundary defined by the weights of the trained linear classifier.  Include both plots in your submission. The template notebook for this problem contains a helper function for producing plots given a trained classifier.

What differences do you see in the decision boundaries learned using the different loss functions? Provide a qualitative explanation for this behavior.

\begin{solution}
  \href{https://colab.research.google.com/drive/1VjRsAW8tTSVNla07FEH3yLSqAfo9t536?usp=sharing}{Code Link}

  https://colab.research.google.com/drive/1VjRsAW8tTSVNla07FEH3yLSqAfo9t536?usp=sharing

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/1b_ridge.png}
    \caption{Result of ridge regression}
    \label{fig:1b_ridge}
  \end{figure}

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/1b_log.png}
    \caption{Result of logistic regression}
    \label{fig:1b_log}
  \end{figure}

  The ridge regression model splits the cluster of red points while the logistic regression boundary separates the two clusters. This is because ridge regression uses least-squares loss, so the furthest cluster of red points "drag" the weight vector out, since the model needs to minimize the squared distance to those points. Logistic regression, on the other hand, has a loss based on classification errors, so it is more likely to separate the clusters of points based on classification.
\end{solution}

\newpage

\problem[9]
Leaving squared loss behind, let's focus on log loss and hinge loss. Consider the set of points $S = \{(\frac{1}{2}, 3), (2, -2), (-3, 1)\}$ in 2D space, shown below, with labels $(1, 1, -1)$ respectively.

Given a linear model with weights $w_0 = 0, w_1 = 1, w_2 = 0$ (where $w_0$ corresponds to the bias term), compute the gradients $\nabla_{w}L_{\text{hinge}}$ and $\nabla_{w}L_{\text{log}}$ of the hinge loss and log loss, and calculate their values for each point in S.

\begin{center}
  \includegraphics[width=.8\textwidth]{./images/SimpleDatasetWithDecisionBoundary.png}
\end{center}
\begin{small}
  The example dataset and decision boundary described above. Positive instances are
  represented by red x's, while negative instances appear as blue dots.
\end{small}

\begin{solution}
  For hinge loss,

  \[
    \nabla_w L = 
      \begin{cases}
        -y x & y(w\cdot x) < 1\\
        0 & y(w \cdot x) > 1
      \end{cases}
  \]

  Calculating for the 3 points,

  \begin{align*}
    x =
      \begin{bmatrix}
        1 \\ \frac{1}{2} \\ 3
      \end{bmatrix},
    y = 1
    &\Rightarrow
    \nabla_w L(x,y) =
      \begin{bmatrix}
        -1 \\ -\frac{1}{2} \\ -3
      \end{bmatrix}\\
    x =
      \begin{bmatrix}
        1 \\ 2 \\ -2
      \end{bmatrix},
    y = 1
    &\Rightarrow
    \nabla_w L(x,y) =
      0\\
    x =
      \begin{bmatrix}
        1 \\-3 \\ 2
      \end{bmatrix},
    y = -1
    &\Rightarrow
    \nabla_w L(x,y) =
      0
  \end{align*}

  For logistic loss,
  \[
    \nabla_w L(x,y) = - \frac{y x e^{-y w \cdot x}}{1 + e^{-y w \cdot x}}
  \]

  Calculating for the 3 points,

  \begin{align*}
    x =
      \begin{bmatrix}
        1 \\ \frac{1}{2} \\ 3
      \end{bmatrix},
    y = 1
    &\Rightarrow
    \nabla_w L(x,y) =
      -\frac{e^{-\frac{1}{2}}}{1+e^{-\frac{1}{2}}}
      \begin{bmatrix}
        1 \\ \frac{1}{2} \\ 3
      \end{bmatrix}
      =
      \begin{bmatrix}
        -0.3775 \\ -0.1888 \\ -1.1326
      \end{bmatrix}\\
    x =
      \begin{bmatrix}
        1 \\ 2 \\ -2
      \end{bmatrix},
    y = 1
    &\Rightarrow
    \nabla_w L(x,y) =
      -\frac{e^{-2}}{1+e^{-2}}
      \begin{bmatrix}
        1 \\ 2 \\ -2
      \end{bmatrix}
      =
      \begin{bmatrix}
        -0.1192 \\ -0.2384 \\ 0.2384
      \end{bmatrix}\\
    x =
      \begin{bmatrix}
        1 \\-3 \\ 1
      \end{bmatrix},
    y = -1
    &\Rightarrow
    \nabla_w L(x,y) =
      \frac{e^{-3}}{1+e^{-3}}
      \begin{bmatrix}
        1 \\-3 \\ 1
      \end{bmatrix}
      =
      \begin{bmatrix}
        0.0474 \\ -0.1423 \\ 0.0474
      \end{bmatrix}
  \end{align*}
\end{solution}

\problem[4]
Compare the gradients resulting from log loss to those resulting from hinge loss. When (if ever) will these gradients converge to 0? For a linearly separable dataset, is there any way to reduce or altogether eliminate training error without changing the decision boundary?

\begin{solution}
  For log loss, the gradients become smaller, but never go exactly to 0. For hinge loss, the gradient converges to 0 if the correctly classified point is at least 1 away from the decision boundary. For a linearly separable dataset, it is not possible to eliminate training error for logistic loss, since it will always be non-zero by definition. For hinge loss, the training error cannot be eliminated if non-zero, but it is possible for the hinge loss to have no training error.
\end{solution}

\problem[5]
Based on your answer to the previous question, explain why for an SVM to be a ``maximum margin'' classifier, its learning objective must not be to minimize just $L_\text{hinge}$, but to minimize $L_\text{hinge} + \lambda\Vert w \Vert^2$ for some $\lambda > 0$.

(You don't need to prove that minimizing $L_\text{hinge} + \lambda\Vert w \Vert^2$ results in a maximum margin classifier; just show that the additional penalty term addresses the issues of minimizing just $L_\text{hinge}$.)

\begin{solution}
  The gradient of hinge loss for correctly classified points at least 1 away from the decision boundary becomes 0. Thus, when all points are classified correctly with a margin of 1, the model stops converging. However, this margin is not the maximum margin. The additional term causes the weight vector to shift until the margin is maximized, not just with a value of 1.
\end{solution}

\newpage
\section{Effects of Regularization}
\textit{Relevant materials: Lecture 3 \& 4}

For this problem, you are required to implement everything yourself and submit code (i.e. don't use scikit-learn but numpy is fine).
\indent\problem[4] 
In order to prevent over-fitting in the least-squares linear regression problem, we add a regularization penalty term.
Can adding the penalty term decrease the training (in-sample) error?
Will adding a penalty term always decrease the out-of-sample errors?
Please justify your answers. Think about the case when there is over-fitting while training the model.

\begin{solution}
  No, adding the term cannot decrease the training error. The model will seek to minimize the training error, but the regularization term and the new optimization objective using it could prevent a minimum training error for a smaller regularization term. At best, the model will match the unregularized training error if the regularization term has a minimum that coincides with the loss function, but it cannot do better.

  Adding a penalty term will not always decrease the out-of-sample error either. Imagine that we add an extremely large regularization term. Then, the model will minimize the regularization term and ignore the training data. This could result in a model that severly underfits the data and thus has a high out-of-sample error.
\end{solution}

\problem[4]
$\ell_1$ regularization is sometimes favored over $\ell_2$ regularization due to its ability to generate a sparse $w$ (more zero weights).
In fact, $\ell_0$ regularization (using $\ell_0$ norm instead of $\ell_1$ or $\ell_2$ norm) can generate an even sparser $w$, which seems favorable in high-dimensional problems.
However, it is rarely used.  Why?

\begin{solution}
  The $L^0$ norm takes on discrete values for the number of non-zero entries in $w$. Thus it is not differentiable and impossible to compute the gradients for. If we are trying to use a gradient-based optimization algorithm such as SGD, we cannot tell how to update the weights to minimize the $L^0$ norm. Additionally, the $L^0$ norm is not convex, so it cannot be optimized.
\end{solution}

\newpage

\subsection{Implementation of \texorpdfstring{$\ell_2$}{L2} regularization:}

We are going to experiment with regression for the Red Wine Quality Rating data set. The data set is uploaded on the course website, and you can read more about it here: \url{https://archive.ics.uci.edu/ml/datasets/Wine}. The data relates 13 different factors (last 13 columns) to wine type (the first column). Each column of data represents a different factor, and they are all continuous features. Note that the original data set has three classes, but one was removed to make this a binary classification problem.

Download the data for training and validation from the assignments data folder.
There are two training sets, wine\_training1.txt (100 data points) and wine\_training2.txt (a proper subset of wine\_training1.txt containing only 40 data points), and one test set, wine\_validation.txt (30 data points). You will use the wine\_validation.txt dataset to evaluate your models.

We will train a \emph{$\ell_2$-regularized logistic regression} model on this data. Recall that the unregularized logistic error (a.k.a. log loss) is
\[E = -\sum_{i=1}^{N}\log(p(y_i | \mathbf{x}_i))\]

where $p(y_i = -1 | \mathbf{x}_i)$ is
\[\frac{1}{1 + e^{\mathbf{w}^T\mathbf{x}_i}}\]

and $p(y_i = 1 | \mathbf{x}_i)$ is
\[\frac{1}{1 + e^{-\mathbf{w}^T\mathbf{x}_i}},\]
where as usual we assume that all $\mathbf{x}_i$ contain a bias term.
The $\ell_2$-regularized logistic error is 
\begin{align*}
  E &= -\sum_{i=1}^{N}\log(p(y_i | \mathbf{x}_i)) + \lambda\mathbf{w}^T\mathbf{w} \\
    &= -\sum_{i=1}^{N} \log \left( \frac{1}{1 + e^{-y_i\mathbf{w}^T\mathbf{x}_i}} \right) + \lambda\mathbf{w}^T\mathbf{w} \\
    &= -\sum_{i=1}^{N} \left(\log \left( \frac{1}{1 + e^{-y_i\mathbf{w}^T\mathbf{x}_i}} \right) - \frac{\lambda}{N}\mathbf{w}^T\mathbf{w}\right).
\end{align*}
Implement SGD to train a model that minimizes the $\ell_2$-regularized logistic error, i.e. train an $\ell_2$-regularized logistic regression model.  Train the model with 15 different values of $\lambda$ starting with $\lambda_0 = 0.00001$ and increasing by a factor of 5, i.e. $$\lambda_0 = 0.00001, \lambda_1 = 0.00005, \lambda_2 = 0.00025, ..., \lambda_{14} = 61,035.15625.$$
\par

Some important notes: Terminate the SGD process after 20,000 epochs, where each epoch performs one SGD iteration for each point in the training dataset. You should shuffle the order of the points before each epoch such that you go through the points in a random order (hint: use \texttt{numpy.random.permutation}). Use a learning rate of $5 \times 10^{-4}$, and initialize your weights to small random numbers. 

You may run into numerical instability issues (overflow or underflow). One way to deal with these issues is by normalizing the input data $X$. Given the column for the $j$th feature, $X_{:,j}$, you can normalize it by setting $X_{ij} = \frac{X_{ij} - \overline{X_{:,j}} }{\sigma(X_{:,j})}$ where $\sigma(X_{:,j})$ is the standard deviation of the $j$th column's entries, and $\overline{X_{:,j}}$ is the mean of the $j$th column's entries. Normalization may change the optimal choice of $\lambda$; the $\lambda$ range given above corresponds to data that has been normalized in this manner. If you treat the input data differently, simply plot enough choices of $\lambda$ to see any trends.

\problem[16]
Do the following for both training data sets (wine\_training1.txt and wine\_training2.txt) and attach your plots in the homework submission (use a log-scale on the horizontal axis):

\subproblem Plot the average training error ($E_\text{in}$) versus different $\lambda$s.

\subproblem Plot the average test error ($E_\text{out}$) versus different $\lambda$s using wine\_validation.txt as the test set.

\subproblem Plot the $\ell_2$ norm of $\mathbf{w}$ versus different $\lambda$s. \medskip

 You should end up with three plots, with two series (one for wine\_training1.txt and one for wine\_training2.txt) on each plot. Note that the $E_\text{in}$ and $E_\text{out}$ values you plot should not include the regularization penalty --- the penalty is only included when performing gradient descent.

\begin{solution}
  \href{https://colab.research.google.com/drive/19-iOw1Acna3jRDQlfqKoDdRcoWjpk4l0?usp=sharing}{Code link}

  https://colab.research.google.com/drive/19-iOw1Acna3jRDQlfqKoDdRcoWjpk4l0?usp=sharing

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/2c_1.png}
    \caption{In-sample error plotted for different regularization values}
    \label{fig:2c_1}
  \end{figure}

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/2c_2.png}
    \caption{Out-of-sample error plotted for different regularization values}
    \label{fig:2c_2}
  \end{figure}

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/2c_3.png}
    \caption{L2 norm plotted for different regularization values}
    \label{fig:2c_3}
  \end{figure}
\end{solution}

\problem[4]
Given that the data in wine\_training2.txt is a subset of the data in wine\_training1.txt, compare errors (training and test) resulting from training with wine\_training1.txt (100 data points) versus wine\_training2.txt (40 data points). Briefly explain the differences.

\begin{solution}
  Training on both datasets produces similar training error. However, the test error for training on the smaller dataset was much higher. As the regularization term increased, the two converged in error on the test set. This is because the model overfit on the smaller dataset for low regularization, but as regularization got larger, both models were restricted to underfitting, and the error increased out-of-sample.
\end{solution}

\newpage

\problem[4]
Briefly explain the qualitative behavior (i.e. over-fitting and under-fitting) of the training and test errors with different $\lambda$s while training with data in wine\_training1.txt.

\begin{solution}
  While regularization was low, both training and test error were generally low, so no overfitting or underfitting occured. However, as the regularization term increased, the training and test error both increased, which is an indication of underfitting.
\end{solution}

\problem[4]
Briefly explain the qualitative behavior of the $\ell_2$ norm of $\textbf{w}$ with different $\lambda$s while training with the data in wine\_training1.txt.

\begin{solution}
  As the regularization term increased, the $L^2$ norm decreased. This is because more of the calculated loss is proportionally the value of the norm, so the gradient will choose to minimize the norm to minimize the overall loss more than the logistic loss.
\end{solution}

\problem[4]
If the model were trained with wine\_training2.txt, which $\lambda$ would you choose to train your final model? Why?

\begin{solution}
  The value for lambda that minimized overfitting on the smaller dataset and produced the lowest out-of-sample error was around $\lambda = 10^{-1}$, so the regularization value close to that value would be the one I would choose.
\end{solution}

% Question 2
\newpage
\section{Lasso (\texorpdfstring{$\ell_1$}{L1}) vs. Ridge (\texorpdfstring{$\ell_2$}{L2}) Regularization}
\textit{Relevant materials: Lecture 3}

For this problem, you may use the scikit-learn (or other Python package) implementation of Lasso and Ridge regression --- you don't have to code it yourself.

The two most commonly-used regularized regression models are Lasso ($\ell_1$) regression and Ridge ($\ell_2$) regression.
Although both enforce ``simplicity'' in the models they learn, only Lasso regression results in sparse weight vectors.
This problem compares the effect of the two methods on the learned model parameters.

\problem[12] 
The tab-delimited file problem3data.txt on the course website contains 1000 9-dimensional datapoints.  The first 9 columns contain $x_1,\ldots,x_9$, and the last column contains the target value $y$.

\subproblem
Train a linear regression model on the problem3data.txt data with Lasso regularization for regularization strengths $\alpha$ in the vector given by \texttt{numpy.linspace(0.01, 3, 30)}.
On a single plot, plot each of the model weights $w_1, ..., w_9$ (ignore the bias/intercept) as a function of $\alpha$.

\subproblem
Repeat \textbf{i.} with Ridge regression, and this time using regularization strengths $\alpha \in \{1, 2, 3, \ldots, 1e4\}$.


\subproblem
As the regularization parameter increases, what happens to the number of model weights that are exactly zero with Lasso regression?
What happens to the number of model weights that are exactly zero with Ridge regression?

\medskip
\lstset{
  basicstyle=\small\ttfamily,
  breaklines=true,
  columns=fullflexible
}

\begin{solution}
  \href{https://colab.research.google.com/drive/1MFb8LmIevdUfWzm4alZgalx_ds-Kh64_?usp=sharing}{Code link}

  https://colab.research.google.com/drive/1MFb8LmIevdUfWzm4alZgalx_ds-Kh64_?usp=sharing

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/3a_1.png}
    \caption{Weight parameters plotted for different regularization values, lasso regularization}
    \label{fig:3a_1}
  \end{figure}

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/3a_2.png}
    \caption{Weight parameters plotted for different regularization values, ridge regularization}
    \label{fig:3a_2}
  \end{figure}

  As the regularization strength increases, the number of weights that go to 0 increases for Lasso regression. For Ridge regression, none of the weights go exactly to 0, but they become much smaller values.
\end{solution}

\problem[9]

\subproblem
In the case of 1-dimensional data, Lasso regression admits a closed-form solution.
Given a dataset containing $N$ datapoints, each with $d = 1$ feature, solve for
\[\underset{w}{\argmin} \Vert\mathbf{y} - \mathbf{x}w\Vert^2 + \lambda\Vert w\Vert_1,
\]
where $\mathbf{x} \in \mathbb{R}^{N}$ is the vector of datapoints and $\mathbf{y} \in \mathbb{R}^N$ is the  vector of all output values corresponding to these datapoints. Just consider the case where $d = 1$, $\lambda \geq 0$, and the weight $w$ is a scalar.

This is linear regression with Lasso regularization.

\begin{subsolution}
  In one dimension,
  \[
    L(x, y, w) = ||y - xw||^2 + \lambda ||w||_1 = (y-xw)^2 + \lambda w
  \]
  To find the closed form solution,
  \begin{align*}
    0 &= \frac{d}{dw} L(x,y,w)\\
    &= \frac{d}{dw} (x^2 w^2 - 2ywx + y^2 + \lambda w\\
    &= 2 x^2 w - 2yx + \lambda\\
    w &= \frac{2yx - \lambda}{2 x^2}
  \end{align*}
\end{subsolution}

\subproblem
In this question, we continue to consider Lasso regularization in 1-dimension. Now, suppose that $w \neq 0$ when $\lambda = 0$. Does there exist a value for $\lambda$ such that $w = 0$? If so, what is the smallest such value?

\begin{subsolution}
  The smallest such value is $\lambda = 2yx$, so the numerator of the closed-form solution becomes 0.
\end{subsolution}

\problem[9]
\subproblem
Given a dataset containing $N$ datapoints each with $d$ features, solve for
\[\underset{\mathbf{w}}{\argmin} \Vert\mathbf{y} - \mathbf{X}\mathbf{w}\Vert^2 + \lambda\Vert\mathbf{w}\Vert_2^2
\]
where $\mathbf{X} \in \mathbb{R}^{N \times d}$ is the matrix of datapoints and $\mathbf{y} \in \mathbb{R}^N$ is the  vector of all output values for these datapoints. Do so for arbitrary $d$ and $\lambda \geq 0$.

This is linear regression with Ridge regularization.

\begin{subsolution}
  Again, we take the derivative and set to 0.
  \begin{align*}
    0 &= 2 X^T (y - X w) + 2 \lambda w\\
    \lambda w &= X^T y - X^T X w\\
    (\lambda I + X^T X) w &= X^T y\\
    w &= (\lambda I + X^T X)^{-1} X^T y
  \end{align*}
\end{subsolution}

\subproblem In this question, we consider Ridge regularization in 1-dimension. Suppose that $w \neq 0$ when $\lambda = 0$. Does there exist a value for $\lambda > 0$ such that $w = 0$? If so, what is the smallest such value?

\begin{subsolution}
  There is no such value, since the matrix $(\lambda I + X^T X)$ cannot become 0 if it is not 0 when $\lambda = 0$.
\end{subsolution}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End: